{"id":695537769,"lang":"python3","time":"4 weeks, 1 day","timestamp":1652020153,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/695537769/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def inorder(self, src, l=[]):\n        if src is not None:\n            il = self.inorder(src.left)\n            il.append(src.val)\n            il.extend(self.inorder(src.right))\n            return il\n        else:\n            return []\n    \n    def preorder(self, src, l=[]):\n        if src is not None:\n            il = [src.val]\n            il.extend(self.preorder(src.left))\n            il.extend(self.preorder(src.right))\n            return il\n        else:\n            return []\n    \n    def constructTree(self, preorder, inorder):\n        def array_to_tree(left, right):\n            nonlocal preorder_index\n            # if there are no elements to construct the tree\n            if left > right: return None\n\n            # select the preorder_index element as the root and increment it\n            root_value = preorder[preorder_index]\n            root = TreeNode(root_value)\n\n\n            preorder_index += 1\n\n            # build left and right subtree\n            # excluding inorder_index_map[root_value] element because it's the root\n            root.left = array_to_tree(left, inorder_index_map[root_value] - 1)\n            root.right = array_to_tree(inorder_index_map[root_value] + 1, right)\n\n            return root\n\n        preorder_index = 0\n\n        # build a hashmap to store value -> its index relations\n        inorder_index_map = {}\n        for index, value in enumerate(inorder):\n            inorder_index_map[value] = index\n\n        return array_to_tree(0, len(preorder) - 1)\n            \n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if root is None:\n            return \"\"\n        else:\n            ino = self.inorder(root)\n            pre = self.preorder(root)\n            \n            s1 = '.'.join([str(x) for x in ino])\n            s2 = '.'.join([str(x) for x in pre])\n            # print(s1);print(s2)\n            return s1+'='+s2\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if len(data) == 0:\n            return None\n        else:\n            [s1, s2] = data.split('=')\n            ino = []\n            a1 = s1.split('.')\n            for x in a1:\n                ino.append(int(x))\n\n            pre = []\n            a2 = s2.split('.')\n            for x in a2:\n                pre.append(int(x))\n            root = self.constructTree(pre, ino)\n            return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))","compare_result":"1111111110000000000000000000000000000000000000000000","title_slug":"serialize-and-deserialize-binary-tree"}