{"id":695804953,"lang":"python3","time":"4Â weeks","timestamp":1652057221,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/695804953/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def inorder(self, src, l=[]):\n        if src is not None:\n            il = self.inorder(src.left)\n            il.append(src.val)\n            il.extend(self.inorder(src.right))\n            return il\n        else:\n            return []\n    \n    def preorder(self, src, l=[]):\n        if src is not None:\n            il = [src.val]\n            il.extend(self.preorder(src.left))\n            il.extend(self.preorder(src.right))\n            return il\n        else:\n            return []\n    \n    def constructTree(self, preorder, inorder):\n#         def array_to_tree(left, right):\n#             nonlocal preorder_index\n#             # if there are no elements to construct the tree\n#             if left > right: return None\n\n#             # select the preorder_index element as the root and increment it\n#             root_value = preorder[preorder_index]\n#             root = TreeNode(root_value)\n\n\n#             preorder_index += 1\n\n#             # build left and right subtree\n#             # excluding inorder_index_map[root_value] element because it's the root\n#             root.left = array_to_tree(left, inorder_index_map[root_value] - 1)\n#             root.right = array_to_tree(inorder_index_map[root_value] + 1, right)\n\n#             return root\n\n#         preorder_index = 0\n\n#         # build a hashmap to store value -> its index relations\n#         inorder_index_map = {}\n#         for index, value in enumerate(inorder):\n#             inorder_index_map[value] = index\n\n#         return array_to_tree(0, len(preorder) - 1)\n        if len(inorder) > 0 and len(preorder) > 0:\n            root = TreeNode(val=preorder[0])\n\n            i = 0\n            while inorder[i] != root.val:\n                i += 1\n            # anything left of i (inorder) is left subtree\n            root.left = self.constructTree(preorder[1:i+1], inorder[:i])\n            root.right = self.constructTree(preorder[i+1:], inorder[i+1:])\n\n            return root\n        else:\n            return None\n            \n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if root is None:\n            return \"\"\n        else:\n            ino = self.inorder(root)\n            pre = self.preorder(root)\n            # print(ino)\n            # print(pre)\n            s1 = '.'.join([str(x) for x in ino])\n            s2 = '.'.join([str(x) for x in pre])\n            \n            return s1+'='+s2\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if len(data) == 0:\n            return None\n        else:\n            [s1, s2] = data.split('=')\n            ino = []\n            a1 = s1.split('.')\n            for x in a1:\n                ino.append(int(x))\n\n            pre = []\n            a2 = s2.split('.')\n            for x in a2:\n                pre.append(int(x))\n            root = self.constructTree(pre, ino)\n            return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))","compare_result":"1111111111111111011111010111111110111111100101000000","title_slug":"serialize-and-deserialize-binary-tree"}