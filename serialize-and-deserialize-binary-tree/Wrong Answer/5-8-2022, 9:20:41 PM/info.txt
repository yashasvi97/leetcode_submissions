{"id":695817659,"lang":"python3","time":"4Â weeks","timestamp":1652059241,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/695817659/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def inorder(self, src, inol):\n        if src is not None:\n            left = self.inorder(src.left, [])\n            if len(left) != 0:\n                inol.extend(left)\n            inol.append(src.val)\n            right = self.inorder(src.right, [])\n            if len(right) != 0:\n                inol.extend(right)\n        return inol\n    \n    def preorder(self, src, prel):\n        if src is not None:\n            prel.append(src.val)\n            left = self.preorder(src.left, [])\n            if len(left) != 0:\n                prel.extend(left)\n            right = self.preorder(src.right, [])\n            if len(right) != 0:\n                prel.extend(right)\n        return prel\n    \n    def constructTree(self, preorder, inorder):\n#         def array_to_tree(left, right):\n#             nonlocal preorder_index\n#             # if there are no elements to construct the tree\n#             if left > right: return None\n\n#             # select the preorder_index element as the root and increment it\n#             root_value = preorder[preorder_index]\n#             root = TreeNode(root_value)\n\n\n#             preorder_index += 1\n\n#             # build left and right subtree\n#             # excluding inorder_index_map[root_value] element because it's the root\n#             root.left = array_to_tree(left, inorder_index_map[root_value] - 1)\n#             root.right = array_to_tree(inorder_index_map[root_value] + 1, right)\n\n#             return root\n\n#         preorder_index = 0\n\n#         # build a hashmap to store value -> its index relations\n#         inorder_index_map = {}\n#         for index, value in enumerate(inorder):\n#             inorder_index_map[value] = index\n\n#         return array_to_tree(0, len(preorder) - 1)\n#         if len(inorder) > 0 and len(preorder) > 0:\n#             root = TreeNode(val=preorder[0])\n\n#             i = 0\n#             while inorder[i] != root.val:\n#                 i += 1\n#             # anything left of i (inorder) is left subtree\n#             root.left = self.constructTree(preorder[1:i+1], inorder[:i])\n#             root.right = self.constructTree(preorder[i+1:], inorder[i+1:])\n\n#             return root\n#         else:\n#             return None\n        def return_tree(part_inorder):\n            if not part_inorder:\n                return None\n            partition_root = preorder.pop(0)\n            partition_root_index = part_inorder.index(partition_root)\n            left_partition = return_tree(part_inorder[:partition_root_index])\n            right_partition = return_tree(part_inorder[partition_root_index+1:])\n            return TreeNode(partition_root, left_partition, right_partition)\n        \n        return return_tree(inorder)\n            \n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if root is None:\n            return \"\"\n        else:\n            ino = self.inorder(root, [])\n            print(ino)\n            pre = self.preorder(root, [])\n            print(pre)\n            \n            s1 = '.'.join([str(x) for x in ino])\n            s2 = '.'.join([str(x) for x in pre])\n            \n            return s1+'='+s2\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if len(data) == 0:\n            return None\n        else:\n            [s1, s2] = data.split('=')\n            ino = []\n            a1 = s1.split('.')\n            for x in a1:\n                ino.append(int(x))\n\n            pre = []\n            a2 = s2.split('.')\n            for x in a2:\n                pre.append(int(x))\n            root = self.constructTree(pre, ino)\n            return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))","compare_result":"1111111111111111011111010111111110111111100101000000","title_slug":"serialize-and-deserialize-binary-tree"}